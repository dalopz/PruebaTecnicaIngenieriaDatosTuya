# PruebaTecnicaIngenieriaDatosTuya -  David L√≥pez Cuervo


## Desarrollo del Ejercicio 1

Se implement√≥ una soluci√≥n en Python que permite procesar archivos HTML, encontrar las imagenes referenciadas mediante el tag `<img>` y reemplazar estas imagenes con sus representaciones en formato Base64.

### Estructura del Proyecto

El desarrollo del ejercicio 1 est√° compuesto por varias clases que se encargan de diferentes partes del procesamiento:

1. **`HTMLImageParser`**:
   Esta clase analiza los archivos HTML y extraer las rutas de las imagenes referenciadas mediante el tag `<img>`. Utiliza un enfoque basado en la librer√≠a `HTMLParser` para procesar el contenido del HTML y obtener todos los valores de los atributos `src` de las imagenes.

2. **`ImageBase64Converter`**:
   Esta clase se encarga de convertir las imagenes a formato Base64. Toma una ruta de archivo de imagen y la convierte en una cadena Base64, que luego puede ser utilizada para reemplazar la ruta original de la imagen en el archivo HTML.

3. **`HTMLProcessor`**:
   Esta es la clase principal que orquesta el procesamiento. Su objetivo es:
   - Recibir una lista de archivos HTML o directorios que contengan archivos HTML.
   - Para cada archivo HTML, extraer las rutas de las imagenes mediante `HTMLImageParser`.
   - Convertir cada imagen a Base64 utilizando `ImageBase64Converter`.
   - Reemplazar las rutas de las imagenes en el HTML con los datos codificados en Base64.
   - Guardar el archivo HTML resultante en una carpeta de salida espec√≠fica.
   - Registrar los resultados del procesamiento, indicando qu√© imagenes se procesaron con √©xito y cu√°les fallaron.

### Flujo de procesamiento

El proceso de conversi√≥n se realiza de la siguiente manera:

1. **Recopilaci√≥n de archivos HTML**: 
   La herramienta puede recibir ya sea una lista de archivos HTML espec√≠ficos o una lista de directorios. Si se proporcionan directorios, el sistema recursivamente busca todos los archivos `.html` dentro de esos directorios, incluyendo subdirectorios.

2. **Procesamiento de cada archivo HTML**:
   Para cada archivo HTML, se extraen todas las imagenes referenciadas con el tag `<img>`. Las rutas de estas imagenes se obtienen del atributo `src` de cada etiqueta.

3. **Conversi√≥n de imagenes a Base64**:
   Cada imagen referenciada se intenta convertir a formato Base64. Si la imagen existe y puede ser convertida correctamente, su c√≥digo Base64 reemplaza la ruta original de la imagen en el archivo HTML.

4. **Resultados**:
   Durante el proceso, se realiza un seguimiento de las imagenes que fueron procesadas correctamente y de aquellas que no pudieron ser convertidas. Los resultados se almacenan en un objeto con dos listas:
   - **`success`**: Contiene las rutas de las imagenes que fueron procesadas exitosamente.
   - **`fail`**: Contiene las rutas de las imagenes que no pudieron ser procesadas (por ejemplo, debido a que el archivo no fue encontrado o la conversi√≥n fall√≥).

5. **Generaci√≥n de archivos de salida**:
   Finalmente, el archivo HTML procesado con las imagenes en Base64 es guardado en una nueva ubicaci√≥n dentro de la carpeta de salida especificada. El nombre del archivo resultante se genera a partir del nombre original, agregando el sufijo `_base64` para diferenciarlo del archivo original.

### Resultado Final

Al finalizar el procesamiento, el sistema retorna un resumen con los resultados de las imagenes procesadas. Se imprime una lista con las imagenes que se han convertido correctamente y una lista con las que no pudieron ser procesadas.

PS C:\David Lopez Cuervo\PruebaTecnicaIngenieriaDatosTuya\Ejercicio1> python main.py --input "test_file/" --output "outputs"
Archivo generado: outputs\prueba_base64.html
Archivo generado: outputs\prueba2_base64.html

Im√°genes procesadas con √©xito:
 - C:\David Lopez Cuervo\PruebaTecnicaIngenieriaDatosTuya\Ejercicio1\test_file\imagen.png
 - C:\David Lopez Cuervo\PruebaTecnicaIngenieriaDatosTuya\Ejercicio1\test_file\imagen2.png

Im√°genes que fallaron:

PS C:\David Lopez Cuervo\PruebaTecnicaIngenieriaDatosTuya\Ejercicio1> 

### Para ejecutarlo 
Coloca tus archivos HTML dentro de la carpeta test_file/ o en su defecto dejar los archivos que ya se encuentran para la prueba
Los archivos HTML deben tener im√°genes que desees convertir a Base64 

Navega al directorio donde est√° el archivo main.py.

Ejecuta el script principal con los siguientes par√°metros:

python main.py --input "test_file/" --output "outputs"     esto para recorrer el directorio

python main.py test_file/prueba.html    esto para un archivo en especifico





## Desarrollo del Ejercicio 2


## üîç An√°lisis y Limpieza de Datos

### CLIENTES

- Se detectaron **14 registros duplicados** en la columna `IDENTIFICACI√ìN`, con clientes distintos compartiendo el mismo valor.
- Esto generaba problemas de integridad referencial, ya que no era posible determinar con certeza qu√© cliente hab√≠a realizado cada transacci√≥n.

#### Opciones Consideradas

1. **Crear un nuevo ID concatenado** (ej. `IDENTIFICACI√ìN` + `nombre` o `tipp  docuemnto` )  
   ‚Üí Rechazado, ya que la hoja `TRANSACCIONES` no ten√≠a suficiente informaci√≥n para replicar esta clave.

2. **Conservar registros activos y eliminar duplicados inactivos**  
   ‚Üí Rechazado, ya que algunos clientes inactivos ten√≠an transacciones v√°lidas previas a la apertura de otro cliente duplicado.

3. **Filtrar por clientes con transacciones v√°lidas (fecha transacci√≥n > apertura tarjeta)**  
   ‚Üí Muy pocos cumpl√≠an con esta regla y no se garantizaba integridad al unir con `TRANSACCIONES`.

#### Soluci√≥n Aplicada

Para continuar con el ejercicio, se eliminaron los duplicados conservando los registros **m√°s recientes**, simulando una regla de negocio donde "el registro v√°lido es el √∫ltimo".  
Esto gener√≥ el archivo `clientes_supuestos.csv` en `data/processed/`.

**Nota:** Esta soluci√≥n fue tomada exclusivamente para fines de esta prueba.  
La **buena pr√°ctica** ser√≠a implementar un gobierno de datos y corregir estas inconsistencias en origen con las personas o area encargada.

---

##  Limpieza y Preparaci√≥n de las Otras Tablas

### TRANSACCIONES

- Validaci√≥n de fechas de transacci√≥n.
- Normalizaci√≥n de estados de tarjeta y tipos de tarjeta.
- Transformaci√≥n de nombres de columnas.

### CATEGORIAS_CONSUMO

- Estandarizaci√≥n y separaci√≥n por dimensiones: ciudad, departamento, categor√≠a general.

### Dimensiones creadas

- `CLASIFICACI√ìN`
- `TIPO_TARJETA`
- `ESTADO_TARJETA`
- `TIPO_DOCUMENTO`
- `CATEGOR√çA_GENERAL`
- `CIUDAD`
- `DEPARTAMENTO`

- `TIEMPO`  
  Se cre√≥ para relacionar las fechas de transacci√≥n a trav√©s de √≠ndices, permitiendo mejores consultas y rendimiento en an√°lisis temporal.

---

##  Creaci√≥n de Base de Datos

- La base de datos `preferencia_consumo` se cre√≥ en MySQL.
- Las tablas fueron creadas y llenadas usando archivos `.csv` desde `data/processed/`, importados con **DBeaver**.
- El script para crear la estructura est√° en:

```bash
scripts/ddl/bd_preferencia_consumo.sql
```
## Vista de Preferencias de Consumo

Se construy√≥ una vista llamada `vista_preferencias_base`, que tiene como objetivo proporcionar una base din√°mica para el an√°lisis de preferencias de consumo de los clientes. Esta vista permite identificar patrones y preferencias en las categor√≠as de consumo a lo largo del tiempo.

### Descripci√≥n de la Vista

La vista `vista_preferencias_base` realiza las siguientes acciones:

1. **Uni√≥n entre tablas**:
   - `CLIENTES` y `TRANSACCIONES`: Para vincular los datos de los clientes con sus transacciones.
   - `TRANSACCIONES` y `CATEGORIAS_CONSUMO`: Para conectar las transacciones con las categor√≠as generales de consumo asociadas.

2. **C√°lculo de la cantidad total de transacciones por cliente y categor√≠a**:
   - Para cada cliente, se calcula cu√°ntas veces ha realizado una transacci√≥n en cada categor√≠a general.

3. **Facilidad de filtrado din√°mico**:
   - Se puede filtrar por niveles de preferencia de los clientes y por ventanas temporales.

### Beneficios de la Vista

- **An√°lisis por niveles de preferencia**: Permite conocer las categor√≠as preferidas de los clientes seg√∫n su volumen de transacciones.
- **Consultas din√°micas**: Se puede ajustar la vista para obtener diferentes resultados seg√∫n los filtros aplicados (e.g., por fecha, categor√≠a, etc.).
- **Facilidad para realizar un seguimiento de cambios**: Permite analizar c√≥mo los h√°bitos de consumo de los clientes cambian con el tiempo.

### Script de la Vista

El script para crear la vista `vista_preferencias_base` est√° contenido en el archivo:

```bash
scripts/ddl/view_preferencia_base.sql
```

## Desarrollo del Ejercicio 3

### 1. An√°lisis exploratorio

Se realiz√≥ una revisi√≥n de las hojas `historia` y `retiros` del archivo `rachas.xlsx` para validar:
- Formato correcto de fechas.
- Ausencia de valores at√≠picos o inconsistencias en los saldos.
- Completitud de los identificadores de clientes.

### 2. Normalizaci√≥n con Dimensi√≥n Tiempo

Para estructurar una base de datos m√°s **normalizada** y facilitar las uniones, se cre√≥ una tabla de dimensi√≥n `TIEMPO`, que contiene todas las fechas √∫nicas de los cortes de mes. Esto permite:
- Eliminar duplicidad de valores de fecha en las tablas principales.
- Mejorar la eficiencia de las consultas y joins.
- Simplificar comparaciones y filtros entre fechas (usando `id_fecha` en lugar de valores DATE).

Las columnas `corte_mes` (en `historia`) y `fecha_retiro` (en `retiros`) se reemplazaron por el correspondiente `id` de la tabla `TIEMPO`. Los datos resultantes fueron exportados como CSV a `data/processed`.

La data original se conserv√≥ en `data/raw` para garantizar trazabilidad y control de versiones.

### 3. Carga de la base de datos

Se implement√≥ un entorno de base de datos usando Docker y la imagen oficial de MySQL. El script de creaci√≥n de esquema y tablas se encuentra en:

```
scripts/ddl/bd_rachas.sql
```

La carga de datos se realiz√≥ desde los archivos CSV procesados utilizando DBeaver.


## Procedimiento almacenado `obtener_rachas`

Este procedimiento resuelve el problema con base en una fecha de corte (`fecha_base`) y una duraci√≥n m√≠nima (`n_min_racha`) y sigue los siguientes pasos:

### 1. Generaci√≥n de combinaciones cliente-fecha
Se obtiene el producto cartesiano de todos los clientes activos con todas las fechas menores o iguales a `fecha_base`, permitiendo reconstruir una serie mensual completa incluso si hay meses faltantes.

### 2. Clasificaci√≥n de saldos por nivel
Se clasifica cada saldo seg√∫n los siguientes rangos:
- `N0`: 0 ‚â§ saldo < 300,000
- `N1`: 300,000 ‚â§ saldo < 1,000,000
- `N2`: 1,000,000 ‚â§ saldo < 3,000,000
- `N3`: 3,000,000 ‚â§ saldo < 5,000,000
- `N4`: saldo ‚â• 5,000,000

Cuando no hay dato de saldo para una fecha espec√≠fica despues de la primera aparici√≥n del cliente y que este no este retirado, se asume nivel `N0`, **excepto si la fecha es posterior a la fecha de retiro del cliente**, en cuyo caso no se incluye.

### 3. Detecci√≥n de rachas

Se calcula un n√∫mero de grupo utilizando diferencias de `ROW_NUMBER` para identificar **subseries consecutivas** con el mismo nivel. Luego se agrupan esas series para contar la longitud de cada racha.

### 4. Filtro y priorizaci√≥n

Se filtran solo aquellas rachas cuya duraci√≥n es mayor o igual a `n_min_racha`. Si un cliente tiene varias, se selecciona:
- La racha m√°s larga.
- En caso de empate, la m√°s reciente (menor o igual a `fecha_base`).

### 5. Resultado final

El procedimiento retorna una tabla con las siguientes columnas:
- `identificacion`
- `nivel` (N0-N4)
- `racha` (cantidad de meses consecutivos)
- `fecha_fin` (fecha de corte de fin de la racha)


## Ejecuci√≥n

## 1. Crear la base de datos y las tablas en mysql

1. Abre el archivo `scripts/ddl/bd_rachas.sql`.
2. Ejecuta el script en tu cliente MySQL para crear el esquema y las tablas necesarias:
   - `TIEMPO`
   - `HISTORIA`
   - `RETIRO`

---

## 2. Cargar los datos procesados

Usando una herramienta como **DBeaver** que fue la usada:

1. Haz clic derecho sobre cada tabla ‚Üí **"Import Data"**.
2. Importa los archivos `.csv` desde la carpeta `data/processed/`:
   - `TIEMPO.csv` ‚Üí tabla `TIEMPO`
   - `HISTORIA.csv` ‚Üí tabla `HISTORIA`
   - `RETIRO.csv` ‚Üí tabla `RETIRO`
3. Aseg√∫rate de mapear correctamente las columnas seg√∫n el orden de cada tabla.
4. Ejecuta la importaci√≥n y verifica que los datos hayan quedado correctamente cargados.

---

## 3. Crear el procedimiento almacenado

1. Abre el archivo `stored_procedures/obtener_rachas.sql`.
2. Ejecuta el contenido del script en tu base de datos para crear el procedimiento `obtener_rachas`.

---

## 4. Ejecutar el procedimiento

Llama al procedimiento para obtener los resultados. Por ejemplo:

```sql
CALL obtener_rachas('2023-03-31', 3);


## Resultado de la ejecuci√≥n

Database changed
mysql> CALL obtener_rachas('2023-03-31', 3);
+-------------------+-------+-------+------------+
| identificacion    | nivel | racha | fecha_fin  |
+-------------------+-------+-------+------------+
| 5CS7MKN5CCCZTYEH8 | N3    |     3 | 2023-03-31 |
| DJXLPRMY5ZZMANLU6 | N4    |     3 | 2023-03-31 |
| K2DBNBQ09G1QCCD7W | N3    |     3 | 2023-03-31 |
| KUD4O3VLEGN7O0D3B | N2    |     3 | 2023-03-31 |
| LATSV8PKLN0G0XSCQ | N3    |     3 | 2023-03-31 |
| MUIZHHC8NUPU3856X | N3    |     3 | 2023-03-31 |
| R7Q4Z9AULIORDJQ9D | N2    |     3 | 2023-03-31 |
| V4LNPTIOKCV53PIHE | N3    |     3 | 2023-03-31 |
+-------------------+-------+-------+------------+
8 rows in set (0.06 sec)

Query OK, 0 rows affected (0.06 sec)

